"""\n深度图 SLAM 避障系统\n基于 Berxel 3D 相机的实时障碍物检测与路径规划\n\n功能:\n1. 实时获取深度图数据\n2. 障碍物检测与分割\n3. 可通行区域分析\n4. 简单的路径规划建议\n5. 3D点云可视化（可选）\n\n作者: Zhuo\n日期: 2025-10-15\n"""\n\nimport cv2\nimport numpy as np\nfrom typing import Tuple, List, Optional\nimport time\n\n\nclass DepthSLAMObstacleDetector:\n    """基于深度图的 SLAM 避障检测器"""\n    \n    def __init__(self, \n                 depth_threshold_near: float = 0.3,  # 近距离阈值(米)\n                 depth_threshold_far: float = 5.0,   # 远距离阈值(米)\n                 obstacle_height_min: float = 0.1,   # 最小障碍物高度(米)\n                 grid_resolution: float = 0.05):      # 网格分辨率(米)\n        """\n        初始化深度SLAM避障检测器\n        \n        Args:\n            depth_threshold_near: 近距离阈值（小于此值的认为太近）\n            depth_threshold_far: 远距离阈值（大于此值的忽略）\n            obstacle_height_min: 最小障碍物高度\n            grid_resolution: 占据栅格地图的分辨率\n        """\n        self.depth_threshold_near = depth_threshold_near\n        self.depth_threshold_far = depth_threshold_far\n        self.obstacle_height_min = obstacle_height_min\n        self.grid_resolution = grid_resolution\n        \n        # 占据栅格地图 (Occupancy Grid)\n        self.occupancy_map = None\n        self.map_size = (200, 200)  # 10m x 10m @ 5cm分辨率\n        self.robot_position = (self.map_size[0] // 2, self.map_size[1] // 2)\n        \n        # 统计信息\n        self.frame_count = 0\n        self.processing_times = []\n        \n    def process_depth_frame(self, depth_image: np.ndarray, \n                           color_image: Optional[np.ndarray] = None) -> Tuple[np.ndarray, dict]:\n        """\n        处理单帧深度图像\n        \n        Args:\n            depth_image: 深度图 (单位: 米)\n            color_image: 彩色图像 (可选)\n            \n        Returns:\n            obstacle_mask: 障碍物掩码\n            info: 检测信息字典\n        """\n        start_time = time.time()\n        \n        # 1. 深度图预处理\n        depth_filtered = self._filter_depth(depth_image)\n        \n        # 2. 障碍物检测\n        obstacle_mask = self._detect_obstacles(depth_filtered)\n        \n        # 3. 更新占据栅格地图\n        self._update_occupancy_map(depth_filtered, obstacle_mask)\n        \n        # 4. 可通行区域分析\n        navigable_zones = self._find_navigable_zones(obstacle_mask)\n        \n        # 5. 路径规划建议\n        suggested_direction = self._suggest_direction(navigable_zones)\n        \n        # 统计信息\n        processing_time = time.time() - start_time\n        self.processing_times.append(processing_time)\n        self.frame_count += 1\n        \n        info = {\n            'frame_count': self.frame_count,\n            'processing_time': processing_time,\n            'avg_processing_time': np.mean(self.processing_times[-30:]),\n            'obstacle_count': np.sum(obstacle_mask > 0),\n            'navigable_zones': navigable_zones,\n            'suggested_direction': suggested_direction,\n            'min_depth': np.min(depth_filtered[depth_filtered > 0]) if np.any(depth_filtered > 0) else 0,\n            'max_depth': np.max(depth_filtered[depth_filtered > 0]) if np.any(depth_filtered > 0) else 0,\n        }\n        \n        return obstacle_mask, info\n    \n    def _filter_depth(self, depth: np.ndarray) -> np.ndarray:\n        """\n        深度图滤波与去噪\n        \n        Args:\n            depth: 原始深度图\n            \n        Returns:\n            filtered_depth: 滤波后的深度图\n        """\n        # 去除无效值\n        depth_valid = depth.copy()\n        depth_valid[depth_valid <= 0] = 0\n        depth_valid[depth_valid > self.depth_threshold_far] = 0\n        \n        # 中值滤波去噪\n        depth_filtered = cv2.medianBlur(depth_valid.astype(np.float32), 5)\n        \n        # 双边滤波保留边缘\n        depth_filtered = cv2.bilateralFilter(\n            depth_filtered.astype(np.float32), 9, 75, 75\n        )\n        \n        return depth_filtered\n    \n    def _detect_obstacles(self, depth: np.ndarray) -> np.ndarray:\n        """\n        检测障碍物\n        \n        Args:\n            depth: 滤波后的深度图\n            \n        Returns:\n            obstacle_mask: 障碍物掩码 (0=可通行, 255=障碍物)\n        """\n        h, w = depth.shape\n        obstacle_mask = np.zeros((h, w), dtype=np.uint8)\n        \n        # 1. 近距离障碍物（太近的物体）\n        near_obstacles = (depth > 0) & (depth < self.depth_threshold_near)\n        obstacle_mask[near_obstacles] = 255\n        \n        # 2. 使用深度梯度检测障碍物边缘\n        # 计算深度梯度\n        depth_grad_x = cv2.Sobel(depth, cv2.CV_32F, 1, 0, ksize=3)\n        depth_grad_y = cv2.Sobel(depth, cv2.CV_32F, 0, 1, ksize=3)\n        depth_grad = np.sqrt(depth_grad_x**2 + depth_grad_y**2)\n        \n        # 梯度大的区域可能是障碍物边缘\n        edge_obstacles = depth_grad > 0.5  # 阈值可调\n        obstacle_mask[edge_obstacles] = 255\n        \n        # 3. 形态学处理：膨胀以增加安全区域\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))\n        obstacle_mask = cv2.dilate(obstacle_mask, kernel, iterations=2)\n        \n        return obstacle_mask\n    \n    def _update_occupancy_map(self, depth: np.ndarray, obstacle_mask: np.ndarray):\n        """\n        更新占据栅格地图\n        \n        Args:\n            depth: 深度图\n            obstacle_mask: 障碍物掩码\n        """\n        if self.occupancy_map is None:\n            self.occupancy_map = np.zeros(self.map_size, dtype=np.float32)\n        \n        # TODO: 实现从深度图到占据栅格的投影\n        # 这里需要相机内参才能准确投影\n        pass\n    \n    def _find_navigable_zones(self, obstacle_mask: np.ndarray) -> List[dict]:\n        """\n        寻找可通行区域\n        \n        Args:\n            obstacle_mask: 障碍物掩码\n            \n        Returns:\n            navigable_zones: 可通行区域列表\n        """\n        # 反转掩码：可通行区域为白色\n        navigable = cv2.bitwise_not(obstacle_mask)\n        \n        # 连通域分析\n        num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(\n            navigable, connectivity=8\n        )\n        \n        zones = []\n        for i in range(1, num_labels):  # 跳过背景\n            area = stats[i, cv2.CC_STAT_AREA]\n            if area > 1000:  # 最小面积阈值\n                zone = {\n                    'id': i,\n                    'area': area,\n                    'centroid': centroids[i],\n                    'bbox': (stats[i, cv2.CC_STAT_LEFT],\n                            stats[i, cv2.CC_STAT_TOP],\n                            stats[i, cv2.CC_STAT_WIDTH],\n                            stats[i, cv2.CC_STAT_HEIGHT])\n                }\n                zones.append(zone)\n        \n        # 按面积排序\n        zones.sort(key=lambda x: x['area'], reverse=True)\n        \n        return zones\n    \n    def _suggest_direction(self, navigable_zones: List[dict]) -> str:\n        """\n        根据可通行区域建议移动方向\n        \n        Args:\n            navigable_zones: 可通行区域列表\n            \n        Returns:\n            direction: 建议方向 ('forward', 'left', 'right', 'stop')\n        """\n        if not navigable_zones:\n            return 'stop'\n        \n        # 选择最大的可通行区域\n        largest_zone = navigable_zones[0]\n        centroid_x = largest_zone['centroid'][0]\n        \n        # 假设图像宽度\n        image_width = 640  # TODO: 从实际图像获取\n        center_x = image_width / 2\n        \n        # 根据质心位置决定方向\n        if abs(centroid_x - center_x) < image_width * 0.2:\n            return 'forward'\n        elif centroid_x < center_x:\n            return 'left'\n        else:\n            return 'right'\n    \n    def visualize(self, depth_image: np.ndarray, \n                  obstacle_mask: np.ndarray,\n                  info: dict,\n                  color_image: Optional[np.ndarray] = None) -> np.ndarray:\n        """\n        可视化检测结果\n        \n        Args:\n            depth_image: 原始深度图\n            obstacle_mask: 障碍物掩码\n            info: 检测信息\n            color_image: 彩色图像（可选）\n            \n        Returns:\n            vis_image: 可视化图像\n        """\n        # 深度图伪彩色\n        depth_normalized = np.zeros_like(depth_image)\n        cv2.normalize(depth_image, depth_normalized, 0, 255, cv2.NORM_MINMAX)\n        depth_colored = cv2.applyColorMap(\n            depth_normalized.astype(np.uint8),\n            cv2.COLORMAP_JET\n        )\n        \n        # 叠加障碍物掩码\n        obstacle_colored = cv2.cvtColor(obstacle_mask, cv2.COLOR_GRAY2BGR)\n        obstacle_colored[:, :, 0] = 0  # 只保留红色通道\n        \n        vis_image = cv2.addWeighted(depth_colored, 0.7, obstacle_colored, 0.3, 0)\n        \n        # 绘制可通行区域\n        for zone in info['navigable_zones'][:3]:  # 显示前3个最大区域\n            cx, cy = zone['centroid']\n            cv2.circle(vis_image, (int(cx), int(cy)), 10, (0, 255, 0), -1)\n            cv2.putText(vis_image, f\"Zone {zone['id']}\", \n                       (int(cx) + 15, int(cy)), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)\n        \n        # 显示方向建议\n        direction = info['suggested_direction']\n        direction_color = (0, 255, 0) if direction == 'forward' else (0, 255, 255)\n        cv2.putText(vis_image, f\"Direction: {direction}\", \n                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, direction_color, 2)\n        \n        # 显示统计信息\n        cv2.putText(vis_image, f\"FPS: {1000/info['processing_time']:.1f}\", \n                   (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)\n        cv2.putText(vis_image, f\"Min Depth: {info['min_depth']:.2f}m\", \n                   (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)\n        cv2.putText(vis_image, f\"Obstacles: {info['obstacle_count']}\", \n                   (10, 120), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)\n        \n        return vis_image\n